-- StudyPunch Database Schema
-- Consolidated migration with all tables, policies, triggers, and functions
-- Updated: 2024-07-25 12:00:00Z

-- 1. 用户资料表 (与 auth.users 关联)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT NOT NULL,
  email TEXT,
  avatar_url TEXT
);

-- 2. 课程表
CREATE TABLE courses (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name TEXT NOT NULL,
  short_description TEXT,
  description TEXT,
  resources JSONB,
  invite_code UUID UNIQUE NOT NULL DEFAULT gen_random_uuid(), -- 用于私有课程
  visibility TEXT NOT NULL DEFAULT 'private', -- 'public' 或 'private'
  pass_rate_threshold NUMERIC(3, 2) NOT NULL DEFAULT 1.00 CHECK (pass_rate_threshold BETWEEN 0.00 AND 1.00),
  creator_id UUID REFERENCES auth.users(id)
);

-- 3. 课程成员与角色表
CREATE TABLE course_members (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  UNIQUE (course_id, user_id)
);

-- 4. NEW: Punch-card style tasks table
CREATE TABLE punches (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  topic TEXT NOT NULL,
  due_date TIMESTAMPTZ
);

-- 5. NEW: Records of completed punches
CREATE TABLE punch_records (
  punch_id BIGINT NOT NULL REFERENCES punches(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  punched_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (punch_id, user_id)
);

-- 6. NEW: Quizzes table
CREATE TABLE quizzes (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  course_id BIGINT NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  file_path TEXT,
  due_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 7. NEW: Quiz attempts table
CREATE TABLE quiz_attempts (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  quiz_id BIGINT NOT NULL REFERENCES quizzes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  score INT NOT NULL,
  submitted_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);


-- =============================================================================
-- ROW LEVEL SECURITY POLICIES
-- =============================================================================

-- profiles
DROP POLICY IF EXISTS "Authenticated users can view all profiles" ON public.profiles;
DROP POLICY IF EXISTS "Users can only update their own profile" ON public.profiles;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can view all profiles" ON profiles FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can only update their own profile" ON profiles FOR UPDATE USING (auth.uid() = id);

-- courses
DROP POLICY IF EXISTS "Authenticated users can see all courses" ON public.courses;
DROP POLICY IF EXISTS "Course owner can delete their own course" ON public.courses;
DROP POLICY IF EXISTS "Course creator can update course" ON public.courses;
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can see all courses" ON courses FOR SELECT TO authenticated USING (true);
CREATE POLICY "Course owner can delete their own course" ON courses FOR DELETE USING (auth.uid() = creator_id);
CREATE POLICY "Course creator can update course" ON courses FOR UPDATE USING (auth.uid() = creator_id);

-- course_members
DROP POLICY IF EXISTS "Authenticated users can see all course memberships" ON public.course_members;
DROP POLICY IF EXISTS "Users can enroll in courses" ON public.course_members;
DROP POLICY IF EXISTS "Course creator can update members" ON public.course_members;
DROP POLICY IF EXISTS "Course creator can delete members" ON public.course_members;
ALTER TABLE course_members ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can see all course memberships" ON course_members FOR SELECT USING (true);
CREATE POLICY "Users can enroll in courses" ON course_members FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Course creator can update members" ON course_members FOR UPDATE USING (
  auth.uid() = (SELECT creator_id FROM courses WHERE id = course_id)
);
CREATE POLICY "Course creator can delete members" ON course_members FOR DELETE USING (
  auth.uid() = (SELECT creator_id FROM courses WHERE id = course_id)
);

-- punches
DROP POLICY IF EXISTS "Course members can see punches" ON public.punches;
DROP POLICY IF EXISTS "Course creator can manage punches" ON public.punches;
ALTER TABLE punches ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Course members can see punches" ON punches FOR SELECT TO authenticated USING (true);
CREATE POLICY "Course creator can manage punches" ON punches FOR ALL USING (
  auth.uid() = (SELECT creator_id FROM courses WHERE id = punches.course_id)
);

-- punch_records
DROP POLICY IF EXISTS "Users can see and manage their own punch records" ON public.punch_records;
DROP POLICY IF EXISTS "Course creator can see all punch records in their course" ON public.punch_records;
ALTER TABLE punch_records ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see and manage their own punch records" ON punch_records FOR ALL USING (user_id = auth.uid());
CREATE POLICY "Course creator can see all punch records in their course" ON punch_records FOR SELECT USING (
  auth.uid() = (
    SELECT c.creator_id FROM courses c
    JOIN punches p ON c.id = p.course_id
    WHERE p.id = punch_records.punch_id
  )
);

-- quizzes
DROP POLICY IF EXISTS "Course members can see quizzes" ON public.quizzes;
DROP POLICY IF EXISTS "Course creator can manage quizzes" ON public.quizzes;
ALTER TABLE quizzes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Course members can see quizzes" ON quizzes FOR SELECT TO authenticated USING (
  course_id IN (
    SELECT course_id FROM course_members WHERE user_id = auth.uid()
  )
);
CREATE POLICY "Course creator can manage quizzes" ON quizzes FOR ALL USING (
  auth.uid() = (SELECT creator_id FROM courses WHERE id = quizzes.course_id)
);

-- quiz_attempts
DROP POLICY IF EXISTS "Users can see and manage their own quiz attempts" ON public.quiz_attempts;
DROP POLICY IF EXISTS "Course creator can see all quiz attempts in their course" ON public.quiz_attempts;
ALTER TABLE quiz_attempts ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can see and manage their own quiz attempts" ON quiz_attempts FOR ALL USING (user_id = auth.uid());
CREATE POLICY "Course creator can see all quiz attempts in their course" ON quiz_attempts FOR SELECT USING (
  auth.uid() = (
    SELECT c.creator_id FROM courses c
    JOIN quizzes q ON c.id = q.course_id
    WHERE q.id = quiz_attempts.quiz_id
  )
);


-- =============================================================================
-- FUNCTIONS AND TRIGGERS
-- =============================================================================

-- Function to automatically create a profile for new users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Only create profile if email is not null
  IF NEW.email IS NOT NULL THEN
    INSERT INTO public.profiles (id, username, email, avatar_url)
    VALUES (
      NEW.id,
      COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email, 'User'),
      NEW.email,
      NEW.raw_user_meta_data->>'avatar_url'
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to create profile when user is created
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to get courses for a specific user
CREATE OR REPLACE FUNCTION get_courses_for_user(user_id_param uuid)
RETURNS TABLE(
    id bigint,
    name text,
    short_description text,
    completed_punches bigint,
    total_punches bigint
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.name,
        c.short_description,
        (SELECT COUNT(*)
         FROM punch_records pr
         JOIN punches p_inner ON pr.punch_id = p_inner.id
         WHERE p_inner.course_id = c.id AND pr.user_id = user_id_param) AS completed_punches,
        (SELECT COUNT(*)
         FROM punches p_outer
         WHERE p_outer.course_id = c.id) AS total_punches
    FROM
        courses c
    JOIN
        course_members cm ON c.id = cm.course_id
    WHERE
        cm.user_id = user_id_param;
END;
$$ LANGUAGE plpgsql; 